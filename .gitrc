# .gitrc
# To include this in your .bash environment add this to your .bashrc file (removing ##):
###-------------------------------------------------------------
### User specific git aliases and functions
###-------------------------------------------------------------
##if [ -f ~/.gitrc ]; then
##  . ~/.gitrc # --> Read ~/.gitrc if present
##fi

#-------------------------------------------------------------
# User specific colors
#-------------------------------------------------------------
if [ -f ~/.bash_colors ]; then
  . ~/.bash_colors # --> Read ~/.bash_colors if present
fi

#-----------------------------------------------------------
# Git prompt
#-----------------------------------------------------------
# Git Bash shell command completion
function parse_git_branch {
  git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ \[\1\]/'
}
#PS1="\u@\h:\W \$(parse_git_branch)\$ "

if [ -f ~/.git-prompt.sh ]; then
  . ~/.git-prompt.sh
  PS1='\u@\h \W$(__git_ps1 " (%s)")\$ '
fi

#-----------------------------------------------------------
# Git aliases
#-----------------------------------------------------------
alias gpushom="CMDINFO echo 'gpushom => git push origin master ' > /dev/tty; NORMAL git push origin master;"
alias gpullom="CMDINFO echo 'gpullom => git pull origin master ' > /dev/tty; NORMAL git pull origin master;"
alias gpusho="CMDINFO echo 'gpusho => git push origin ' > /dev/tty; NORMAL git push origin "
alias gpullo="CMDINFO echo 'gpullo => git pull origin ' > /dev/tty; NORMAL git pull origin "
alias gps="CMDINFO echo -n 'gps => ' > /dev/tty; NORMAL gpusho "
alias gpl="CMDINFO echo -n 'gpl => ' > /dev/tty; NORMAL gpullo "
alias gst="CMDINFO echo 'gst => git status ' > /dev/tty; NORMAL git status "
alias gci="CMDINFO echo 'gci => git commit ' > /dev/tty; NORMAL git commit "
alias gco="CMDINFO echo 'gco => git checkout ' > /dev/tty; NORMAL git checkout "
alias gdf="CMDINFO echo 'gdf => git diff ' > /dev/tty; NORMAL git diff "
alias gbr="CMDINFO echo 'gbr => git br ' > /dev/tty; NORMAL git br "
alias aliases="INFO echo '### Available Functions (.bashrc) ###'; NORMAL echo -n; cat ~/.bashrc | grep function; echo -n; INFO echo '### Available Git Functions (.gitrc) ###'; NORMAL echo -n; cat ~/.gitrc | grep function; echo -n; INFO echo '### Git aliases (.gitrc) ###:'; NORMAL echo -n; cat ~/.gitrc | grep alias; echo -n; INFO echo '### Git config aliases (.gitconfig) ###:'; NORMAL git config --list | grep alias; echo -n; INFO echo '### Alias (.bash_alias) ###'; NORMAL alias"

#-----------------------------------------------------------
# Git functions
#-----------------------------------------------------------
function git-each(){ # git-each gitCommand #Usage: git-each gitCommand [bool:include 'origin branchName' - default false]- Ex: git-each fetch; This triggers a loop through each branch and $ git checkout ${branch}; git fetch origin ${branch};
  #!/bin/sh
  #Thanks to: 
  ## http://stackoverflow.com/questions/3846380/how-to-iterate-through-all-git-branches-using-bash-script, 
  ## http://stackoverflow.com/questions/11940977/how-to-update-a-file-across-all-branches-in-a-git-repository?lq=1, 
  ## http://archive.linuxfromscratch.org/lfs-museum/3.1/LFS-BOOK-3.1-HTML/chapter07/functions.html,  
  ## https://wiki.archlinux.org/index.php/Color_Bash_Prompt
  
  #loop through each local branch and act on it. #could be adapted to use remote branches or create an array combining both.

  if [[ ! -n "$1" ]] ; then
    INFO echo 1>&2 "Usage: git-each gitCommand - Ex: git-each fetch; This triggers a loop through each branch and $ git checkout ${branch}; git fetch origin ${branch};"
    NORMAL 
  else
    #$1 => gitCommand
    #$2 => includeOriginBranch:bool (default false)  
    if [[ ! -n "$2" ]] ; then
      includeOriginBranch=false
    else
      if [ $2 == 1 -o $2 == "true" -o  $2 == "TRUE" ] ; then
        includeOriginBranch=true
      fi
    fi
    
    #vars:
    originalBranch="$(git rev-parse --abbrev-ref HEAD)"
    branches=()
    eval "$(git for-each-ref --shell --format='branches+=(%(refname))' refs/remotes/)" #remote branches.
    #eval "$(git for-each-ref --shell --format='branches+=(%(refname))' refs/heads/)" #local branches. W/O refs/heads/ you get both local and remote listings.
      
    #command vars:
    GCMD="git $1"
    GBRA="git branch -a"
    
    #actions:
    INFO echo "Initiating 'git-each $1'. List of local and remote branches: " > /dev/tty;  $GBRA; NORMAL
    for branch in "${branches[@]}"; 
    do
      branchName="$(basename ${branch})"
      if [ $branchName !== "HEAD"] ; #skip refs/remotes/HEAD as it's a symlink
        #Updated CMD Vars
        GCO="git checkout ${branchName}"
        if $includeOriginBranch; then
           GCMD="git $1 origin ${branchName}"
        fi
        INFO echo "1 - Checkout branch: ${branchName}" > /dev/tty; CMDINFO echo "$GCO" > /dev/tty; NORMAL $GCO; ##highlight checkout message
        #SUCCESS echo "branch name: ${branchName}" > /dev/tty; NORMAL
        INFO echo "2 - Execute CMD on branch: " > /dev/tty; CMDINFO echo "$GCMD" > /dev/tty; NORMAL $GCMD
        WARNING echo "##################" > /dev/tty; NORMAL 
      fi
    done
    INFO echo "Complete" > /dev/tty; NORMAL
    INFO echo "Returning to your original branch: " > /dev/tty; CMDINFO echo "git checkout $originalBranch" > /dev/tty; NORMAL git checkout $originalBranch; echo -n; 
    INFO echo "### All branches '$GBRA' ### "; NORMAL $GBRA;
    if [[ $1 == "st" || $1 == "status" ]] ; then
      INFO echo "Possible next steps? - If there is nothing to commit; fetch your branches: " > /dev/tty; echo "git-each fetch" > /dev/tty; echo -n; NORMAL
    fi
    if [[ $1 == "fetch" ]] ; then
      INFO echo "Possible next steps? - Pull your branches: " > /dev/tty; echo "git-each pull" > /dev/tty; echo -n; NORMAL
    fi
    if [[ $1 == "pull" ]] ; then
      INFO echo "Possible next steps? - Push your branches: " > /dev/tty; echo "git-each push" > /dev/tty; echo -n; NORMAL
    fi
  fi
}

function git-create-branch(){ # git-create-branch <branch_name>
  #!/bin/sh
  #from http://www.zorched.net/2008/04/14/start-a-new-branch-on-your-remote-git-repository/comment-page-2/#comment-18065
  if [[ ! -n "$1" ]] ; then
    INFO echo 1>&2 Usage: git-create-branch branch_name
    NORMAL 
  else
    #$1 => branch_name
    #vars:
    GCO="git checkout -b $1";
    GPO="git push origin $1";
    GBRSUP="git branch --set-upstream $1 origin/$1";
    GBR="git branch";
    GBRR="git branch -r";
    #actions:
    INFO echo "Adding $1" NORMAL
    INFO echo "1 - Create the local branch from the current one: " > /dev/tty; CMDINFO echo "$GCO" > /dev/tty; NORMAL $GCO
    INFO echo "2 - Push that branch to the remote: " > /dev/tty; CMDINFO echo "$GPO" > /dev/tty; NORMAL $GPO
    INFO echo "3 - Set the upstream branch to track: " > /dev/tty; CMDINFO echo "$GBRSUP" > /dev/tty; NORMAL $GBRSUP
    INFO echo "4 - To checkout and track the remote branch from another location simply use: git checkout $1 or git checkout -t origin/$1" > /dev/tty; echo -n; NORMAL
    INFO echo "5 - If you need to delete the remote branch use: git-delete-branch $1 or git push origin :$1" > /dev/tty; echo -n; NORMAL
    INFO echo "### Local branches ($GBR) ### "; NORMAL $GBR
    INFO echo "### Remote branches ($GBRR) ### "; NORMAL $GBRR; INFO echo "#Use 'git branch -a' to list all"; NORMAL
  fi
}

function git-delete-branch(){ # git-delete-branch <branch_name>
  #!/bin/sh
  #modified from script and comments at http://www.zorched.net/2008/04/14/start-a-new-branch-on-your-remote-git-repository/comment-page-2/#comment-18065
  #if [ $# -ne 1 ]; then
  if [[ ! -n "$1" ]] ; then
    INFO echo 1>&2 Usage: git-delete-branch branch_name
    NORMAL
  else
    #$1 -> branch_name
    #vars:
    GCO="git checkout master";
    GPOD="git push origin :$1";
    GBRD="git branch -d $1";
    GFO="git fetch origin";
    GPL="git pull origin master"
    GBR="git branch";
    GBRR="git branch -r";
    #Verbose actions:
    INFO echo "Removing $1" NORMAL
    INFO echo "1 - Check out master branch: " > /dev/tty; CMDINFO echo "$GCO" > /dev/tty; NORMAL $GCO
    INFO echo "2 - Delete remote branch: " > /dev/tty; CMDINFO echo "$GPOD" > /dev/tty; NORMAL $GPOD
    INFO echo "3 - Delete local branch: " > /dev/tty; CMDINFO echo "$GBRD" > /dev/tty; NORMAL $GBRD
    INFO echo "4 - fetch and pull origin: " > /dev/tty; CMDINFO echo "$GFO; $GPL;" > /dev/tty; NORMAL $GFO; $GPL;
    INFO echo "### Local branches ($GBR) ### "; NORMAL $GBR
    INFO echo "### Remote branches ($GBRR) ### "; NORMAL $GBRR; INFO echo "#Use 'git branch -a' to list all"; NORMAL
  fi
}

function git-patch(){ # Apply a patch with git. Typical steps: stat, check, apply and if no errors occur use $ git am --signoff < ...patch.  Usage: git-patch stat|check|signoff URL.patch Ex: git-patch stat http://drupal.org/files/features-date-1279928-15.patch
  #!/bin/sh
  #from http://drupal.org/node/1399218
  if [[ ! -n "$1" ]] ; then
    INFO echo 'Usage: git-patch stat|check|apply URL.patch' > /dev/tty; NORMAL
  else
    local URL=$2;
    local patchFilename="$(basename $2)"
    if [[ $1 == "apply" ]] ; then
      if [[ $URL == http* ]] ; then
        CMDINFO echo "sudo wget $URL;" > /dev/tty; NORMAL
        sudo wget $URL; git $1 $patchFilename;
      fi
      CMDINFO echo "git $1 -v $patchFilename " > /dev/tty; NORMAL
      git $1 -v $patchFilename;
      INFO echo "# If the patch applied with no errors then use: "; > /dev/tty; CMDINFO echo "git am --signoff < $patchFilename" > /dev/tty; NORMAL
      INFO echo "# To delete the patch use: "; > /dev/tty; CMDINFO echo " rm $patchFilename" > /dev/tty; NORMAL
    else
      if [[ $URL == http* ]] ; then
        CMDINFO echo "sudo wget $URL;" > /dev/tty; NORMAL
        sudo wget $URL;
      fi
      CMDINFO echo "git apply -v --$1 $patchFilename" > /dev/tty; NORMAL
      git apply -v --$1 $patchFilename;
      INFO echo "Patchname: $patchFilename" > /dev/tty; NORMAL
    fi
    if [[ $1 == "stat" ]] ; then
      INFO echo "# To check the patch use: "; > /dev/tty; CMDINFO echo "git-patch check $patchFilename" > /dev/tty; NORMAL
    fi
    if [[ $1 == "check" ]] ; then
      INFO echo "# To apply the patch use: "; > /dev/tty; CMDINFO echo "git-patch apply $patchFilename" > /dev/tty; NORMAL
    fi
  fi
}
